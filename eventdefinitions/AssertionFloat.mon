package com.dtamai.onspec;

event _AssertionFloatRelative {
  wildcard float actual;

  action testFailed(float expected, float epsilon, string expectation) {
    string reason := actual.toString() + " expected to be " + expectation +
                     " " + expected.toString() + 
                     " (" + epsilon.toString() +
                     ")";
    route Failure(reason);
  }

  // Algorithm: http://floating-point-gui.de/errors/comparison/
  // Uses relative error
  action _nearlyEquals(float expected, float epsilon) returns boolean {
    float absExpected := expected.abs();
    float absActual := actual.abs();
    float diff := (actual - expected).abs();

    if (actual = expected) then {
      return true;
    } else if (actual*expected = 0.0) then {
      return diff < (epsilon*epsilon);
    } else {
      return (diff/(absExpected + absActual)) < epsilon;
    }
  }

  action eq(float expected, float epsilon) {
    if not _nearlyEquals(expected, epsilon) then {
      testFailed(expected, epsilon, "equal");
    }
  }

  action neq(float expected, float epsilon) {
    if _nearlyEquals(expected, epsilon) then {
      testFailed(expected, epsilon, "not equal");
    }
  }

  action gt(float boundary, float epsilon) {
    if not (boundary < actual) then {
      testFailed(boundary, epsilon, "greater than");
    }
  }

  action lt(float boundary, float epsilon) {
    if not (boundary > actual) then {
      testFailed(boundary, epsilon, "less than");
    }
  }

  action gte(float boundary, float epsilon) {
    if not (boundary <= actual or _nearlyEquals(boundary, epsilon)) then {
      testFailed(boundary, epsilon, "greater than or equal");
    }
  }

  action lte(float boundary, float epsilon) {
    if not (boundary >= actual or _nearlyEquals(boundary, epsilon)) then {
      testFailed(boundary, epsilon, "less than or equal");
    }
  }
}
